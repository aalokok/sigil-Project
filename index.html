<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Cybersigil Growth – Branching Animation</title>
  <style>
    html,body{margin:0;height:100%;overflow:hidden;background:#000}
    #hud{position:fixed;top:8px;left:8px;font:12px monospace;color:#eee;z-index:10}
    #hud button { margin-left: 10px; background: #555; color: #fff; border: 1px solid #333; cursor: pointer; padding: 2px 5px;}
    #mirror-controls{ position: fixed; top: 8px; right: 8px; z-index: 10; }
    #mirror-controls button { font:11px monospace; margin-left: 5px; background: #eee; color: #333; border: 1px solid #ccc; padding: 3px 6px; }
    #mirror-controls button.active { background: #333; color: #fff; border-color: #000; }
    #postfx-controls { position: fixed; bottom: 8px; left: 8px; background: rgba(255,255,255,0.8); padding: 10px; border-radius: 5px; z-index: 10; font: 11px monospace; color: #333; }
    #postfx-controls div { margin-bottom: 5px; }
    #postfx-controls label { display: inline-block; width: 120px; }
    #postfx-controls input[type=\"range\"] { width: 150px; vertical-align: middle; }
    #postfx-controls input[type=\"file\"] { margin-top: 5px; }
    #postfx-controls input[type=\"checkbox\"] { vertical-align: middle; }
    #background-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -1; background-size: cover; background-position: center center; }
  </style>
</head>
<body>
  <div id="background-container"></div>
  <div id="hud">SPACE → add branch · R → reset</div>
  <div id="mirror-controls">
    <button id="mirrorXBtn">Mirror X (On)</button>
    <button id="mirrorYBtn">Mirror Y (Off)</button>
    <button id="mirrorZBtn">Mirror Z (Off)</button>
    <button id="invertColorsBtn">Invert Colors (Off)</button>
  </div>
  <div id="postfx-controls">
    <div><label for="noiseAmount">Noise Amount:</label><input type="range" id="noiseAmount" min="0" max="0.2" step="0.001" value="0.03"></div>
    <div><label for="bloomStrength">Bloom Strength:</label><input type="range" id="bloomStrength" min="0" max="3" step="0.1" value="1.5"></div>
    <div><label for="bloomRadius">Bloom Radius:</label><input type="range" id="bloomRadius" min="0" max="1" step="0.01" value="0.4"></div>
    <div><label for="bloomThreshold">Bloom Threshold:</label><input type="range" id="bloomThreshold" min="0" max="1" step="0.01" value="0.85"></div>
    <div><label for="thresholdStrength">Threshold Strength:</label><input type="range" id="thresholdStrength" min="0" max="1" step="0.01" value="0.5"></div>
    <div><label for="imageUpload">Threshold Image:</label><input type="file" id="imageUpload" accept="image/png, image/jpeg"></div>
    <div><label for="inverseThreshold">Inverse Threshold:</label><input type="checkbox" id="inverseThreshold" checked></div>
    <div><label for="audioUpload">Audio File (MP3):</label><input type="file" id="audioUpload" accept="audio/mpeg"></div>
    <audio id="audioPlayer" controls loop></audio>
  </div>
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
    import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
    import { ShaderPass } from 'three/examples/jsm/postprocessing/ShaderPass.js';
    import { OutputPass } from 'three/examples/jsm/postprocessing/OutputPass.js';
    import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';
    import { ThresholdShader } from './ThresholdShader.js'; // Import ThresholdShader
    import { ColorInversionManager } from './ColorInvertShader.js'; // Import ColorInversionManager
    import { Cybersigil, MAX_BRANCH_DEPTH, simplex /*, other constants if needed directly by index.html */ } from './Cybersigil.js'; // Import Cybersigil class and MAX_BRANCH_DEPTH
    // import { MarchingCubes } from 'three/examples/jsm/objects/MarchingCubes.js'; // REMOVED
    // import SimplexNoise from 'simplex-noise'; // REMOVED - Now in Cybersigil.js

    // const simplex = new SimplexNoise(); // REMOVED - Now in Cybersigil.js

    // ── Scene ─────────────────────────────────────────────────────────
    const scene  = new THREE.Scene();
    scene.background = new THREE.Color(0x000000); // Initialize scene background to black
    const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, .1, 1000);
    camera.position.set(0, 14, 90);

    const renderer = new THREE.WebGLRenderer({antialias:true, alpha: true});
    renderer.setClearAlpha(0.0); // Ensure renderer clear color is transparent
    renderer.setPixelRatio(Math.min(devicePixelRatio,2));
    renderer.setSize(innerWidth, innerHeight);
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    let isInteracting = false; // Flag for camera interaction

    controls.addEventListener('start', () => { isInteracting = true; });
    controls.addEventListener('end', () => { isInteracting = false; });

    scene.add(new THREE.HemisphereLight(0xffffff,0x444444,.9));
    const dir = new THREE.DirectionalLight(0xffffff,1.1); dir.position.set(6,12,8); scene.add(dir);

    const pmrem = new THREE.PMREMGenerator(renderer);
    scene.environment = pmrem.fromScene(new THREE.Scene(),.04).texture;

    // Post-processing
    const composer = new EffectComposer(renderer);
    const renderPass = new RenderPass(scene, camera);
    composer.addPass(renderPass);

    // Add Bloom Pass
    const bloomPass = new UnrealBloomPass(
        new THREE.Vector2(innerWidth, innerHeight), // resolution
        1.5,    // strength
        0.4,    // radius
        0.85    // threshold
    );
    composer.addPass(bloomPass);

    const thresholdPass = new ShaderPass(ThresholdShader); 
    if (thresholdPass) thresholdPass.uniforms.uInverseThreshold.value = true; 
    composer.addPass(thresholdPass); 

    // Noise Shader
    const NoiseShader = {
      uniforms: {
        'tDiffuse': { value: null },
        'uTime': { value: 0.0 },
        'uNoiseAmount': { value: 0.1 }
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float uTime;
        uniform float uNoiseAmount;
        varying vec2 vUv;

        float random(vec2 st) {
          return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
        }

        void main() {
          vec4 diffuseColor = texture2D(tDiffuse, vUv);
          float noise = (random(vUv + mod(uTime * 0.1, 100.0)) - 0.5) * uNoiseAmount; // Centered noise
          diffuseColor.rgb += noise;
          gl_FragColor = diffuseColor;
        }
      `
    };
    const noisePass = new ShaderPass(NoiseShader);
    composer.addPass(noisePass);

    const outputPass = new OutputPass();
    composer.addPass(outputPass);

    // Initialize Color Inversion Manager
    let colorInversionManager;
    
    // Wait for composer to be ready, then initialize inversion manager
    setTimeout(() => {
        colorInversionManager = new ColorInversionManager(composer);
        console.log('Color inversion manager initialized');
    }, 100);

    // ── Materials & geometry prototypes ───────────────────────────────
    const chrome = new THREE.MeshStandardMaterial({color:0xd8d8d8,metalness:1,roughness:.12,envMapIntensity:2});
    const debugMaterial = new THREE.MeshBasicMaterial({color: 0x00ff00, wireframe: true });

    // Global Sigil Management
    let allSigils = []; // Will store Cybersigil instances
    // let sigilCreationCounter = 0; // This might be managed internally by Cybersigil or not needed

    // Mirror states remain global for UI interaction
    let mirrorXActive = true; 
    let mirrorYActive = false;
    let mirrorZActive = false;

    // Child limits for density control - COMMENTED OUT for unrestricted growth
    // const MAX_CHILDREN_FOR_ROOT = 6;
    // const MAX_CHILDREN_FOR_SUBBRANCH = 3;

    // NEW Tube Geometry Constants - TO BE REPLACED/REMOVED
    // const TUBE_BASE_RADIUS = 0.3;
    // const TUBE_RADIAL_SEGMENTS = 8; 
    // const TUBE_TUBULAR_SEGMENTS_PER_UNIT_LENGTH = 1.2; 
    // const TUBE_MIN_TUBULAR_SEGMENTS = 10; 
    // const BRANCH_GROWTH_SPEED = 8.0; // MOVED

    // Spike Constants - TO BE REPLACED/REMOVED LATER
    // const SPIKE_PROBABILITY = 0.25; 
    // const SPIKES_PER_UNIT_LENGTH = 1.2; 
    // const SPIKE_BASE_LENGTH = 0.5; 
    // const SPIKE_BASE_RADIUS = 0.01; 
    // const SPIKE_RADIAL_SEGMENTS = 4; 
    // const SPIKE_TAPER_POWER = 0.5; 

    // Dynamic Geometry Constants
    // const MAX_POINTS_PER_BRANCH_PATH = 150; // MOVED
    // OLD: const MAX_VERTICES_FOR_LINE_GEOMETRY = (MAX_POINTS_PER_BRANCH_PATH -1) * 2 * 3;
    // NEW: Each path segment (MAX_POINTS_PER_BRANCH_PATH segments) becomes a quad (6 vertices).
    // OLD: const LINE_THICKNESS = 0.3; 
    // OLD: const LINE_TAPER_POWER = 1.5; 
    // OLD: const LINE_DEPTH_SCALE_FACTOR = 0.75; 

    // New constants for 3D tubes
    // const TUBE_SIDES = 6; // MOVED
    // const TUBE_BASE_RADIUS = 0.25; // MOVED
    // const TUBE_TAPER_POWER = 1.5;  // MOVED
    // const TUBE_DEPTH_SCALE_FACTOR = 0.75; // MOVED
    // const TUBE_INK_BLEED_OFFSET = 0.08; // MOVED

    // Max vertices: path segments * tube sides * 6 vertices per quad
    // THIS IS THE ONLY DEFINITION that should exist for MAX_VERTICES_PER_BRANCH_GEOMETRY
    // const MAX_VERTICES_PER_BRANCH_GEOMETRY = MAX_POINTS_PER_BRANCH_PATH * TUBE_SIDES * 6; // MOVED
    // Ensured old definition is removed by explicitly targeting its previous common location if it was missed.
    // For example, it might have been near line 78 or 90 if based on older constants.

    // New material specifically for branches
    // const BRANCH_MATERIAL = new THREE.MeshStandardMaterial({ ... }); // MOVED
    // const INK_BLEED_MATERIAL = new THREE.MeshStandardMaterial({ ... }); // MOVED

    // Helper vectors and function for triangle strip generation
    // const globalReferenceUp = new THREE.Vector3(0, 1, 0); // MOVED
    // const globalReferenceRight = new THREE.Vector3(1, 0, 0); // MOVED
    // const tempVecP1 = new THREE.Vector3(); // MOVED
    // const tempVecP2 = new THREE.Vector3(); // MOVED
    // const tempTangent1 = new THREE.Vector3(); // MOVED
    // const tempSide = new THREE.Vector3(); // MOVED
    // const tempNormal = new THREE.Vector3(); // MOVED
    // const edge1 = new THREE.Vector3();      // MOVED
    // const edge2 = new THREE.Vector3();      // MOVED
    // const tempBiNormal = new THREE.Vector3(); // MOVED
    // const crossSectionVertex = new THREE.Vector3(); // MOVED

    /* MOVED TO Cybersigil.js
    function getSideVector(tangent, outSideVec) {
        outSideVec.crossVectors(tangent, globalReferenceUp).normalize();
        if (outSideVec.lengthSq() < 0.0001) { // tangent is collinear with referenceUp
            outSideVec.crossVectors(tangent, globalReferenceRight).normalize();
        }
        // Ensure it's truly normalized if cross product was with a near-collinear fallback
        if (outSideVec.lengthSq() < 0.0001) { // very unlikely, e.g. tangent is zero vector
            outSideVec.set(1,0,0); // Default to X axis if all else fails
        }
        return outSideVec;
    }
    */

    // Branch object structure
    /* MOVED TO Cybersigil.js
    function createBranch(startPos, direction, seed, depth){ 
      const SEG_POINTS = MAX_POINTS_PER_BRANCH_PATH;
      const LEN  = (depth === 0) ? 15 : Math.max(3, 15 / (depth * 1.5)); 
      const curvePts  = [];
      for(let i=0;i<=SEG_POINTS;i++){
        const u=i/SEG_POINTS;
        const z=u*LEN;
        const sway = simplex.noise2D(u*2+seed,seed)*1.5 * (1 / (depth + 1));
        const bend = simplex.noise2D(u*2+seed+20,seed-10)*1.5 * (1 / (depth + 1));
        const right = new THREE.Vector3().crossVectors(direction,new THREE.Vector3(0,1,0)).normalize();
        const up    = new THREE.Vector3().crossVectors(right,direction).normalize();
        const p = new THREE.Vector3().copy(startPos)
          .addScaledVector(direction,z)
          .addScaledVector(right,sway)
          .addScaledVector(up,bend);
        curvePts.push(p);
      }

      for (let pt of curvePts) {
        const dx = simplex.noise3D(pt.x * NOISE_DISPLACEMENT_SCALE, pt.y * NOISE_DISPLACEMENT_SCALE, pt.z * NOISE_DISPLACEMENT_SCALE + seed) * NOISE_DISPLACEMENT_STRENGTH * (1/(depth+1));
        const dy = simplex.noise3D(pt.y * NOISE_DISPLACEMENT_SCALE, pt.z * NOISE_DISPLACEMENT_SCALE, pt.x * NOISE_DISPLACEMENT_SCALE + seed + 5) * NOISE_DISPLACEMENT_STRENGTH * (1/(depth+1));
        const dz = simplex.noise3D(pt.z * NOISE_DISPLACEMENT_SCALE, pt.x * NOISE_DISPLACEMENT_SCALE, pt.y * NOISE_DISPLACEMENT_SCALE + seed + 10) * NOISE_DISPLACEMENT_STRENGTH * (1/(depth+1));
        pt.add(new THREE.Vector3(dx, dy, dz));
      }

      const curve = new THREE.CatmullRomCurve3(curvePts);
      const curveLength = curve.getLength();

      const positionsArray = new Float32Array(MAX_VERTICES_PER_BRANCH_GEOMETRY * 3);
      const normalsArray = new Float32Array(MAX_VERTICES_PER_BRANCH_GEOMETRY * 3); // For lighting
      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.BufferAttribute(positionsArray, 3).setUsage(THREE.DynamicDrawUsage));
      geometry.setAttribute('normal', new THREE.BufferAttribute(normalsArray, 3).setUsage(THREE.DynamicDrawUsage)); // Add normal attribute
      
      const mesh = new THREE.Mesh(geometry, BRANCH_MATERIAL); // Use new BRANCH_MATERIAL
      geometry.setDrawRange(0, 0); 
      
      // Ink Bleed Mesh
      const bleedPositionsArray = new Float32Array(MAX_VERTICES_PER_BRANCH_GEOMETRY * 3);
      const bleedNormalsArray = new Float32Array(MAX_VERTICES_PER_BRANCH_GEOMETRY * 3);
      const bleedGeometry = new THREE.BufferGeometry();
      bleedGeometry.setAttribute('position', new THREE.BufferAttribute(bleedPositionsArray, 3).setUsage(THREE.DynamicDrawUsage));
      bleedGeometry.setAttribute('normal', new THREE.BufferAttribute(bleedNormalsArray, 3).setUsage(THREE.DynamicDrawUsage));
      
      const bleedMesh = new THREE.Mesh(bleedGeometry, INK_BLEED_MATERIAL);
      bleedGeometry.setDrawRange(0, 0);

      console.log(`CreateBranch (depth ${depth}, seed ${seed.toFixed(0)}): totalLength=${curveLength.toFixed(2)}, curvePoints.length=${curvePts.length}, MaxVertices=${MAX_VERTICES_PER_BRANCH_GEOMETRY}`);

      return {
        curve,
        curvePoints: curvePts,
        mesh: mesh, 
        bleedMesh: bleedMesh, // Add bleed mesh
        currentLength: 0,
        totalLength: curveLength,
        drawnPathSegments: 0,
        currentVertexCount: 0, 
        currentBleedVertexCount: 0, // For bleed mesh
        childrenSpawned: 0,
        seed,
        depth
      };
    }
    */

    function resetSigil(){
      allSigils.forEach(sigilInstance => {
        sigilInstance.dispose(); // Call dispose method on Cybersigil instance
      });
      allSigils.length = 0;
      // sigilCreationCounter = 0; // Reset if used

      const rootInitialGroupPos = new THREE.Vector3(0,0,-10);
      const primaryRootDir = new THREE.Vector3(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1).normalize();
      if (primaryRootDir.lengthSq() === 0) primaryRootDir.set(0,0,1); 
      const primaryRootSeed = Math.random() * 1000;
      
      // Create the new Cybersigil instance, passing the current mirror states
      const newSigil = new Cybersigil(scene, rootInitialGroupPos, primaryRootDir, primaryRootSeed, mirrorXActive, mirrorYActive, mirrorZActive);
      allSigils.push(newSigil);
      console.log("Main: New Cybersigil instance created and added.");
    }

    // Mirror Button Logic
    const mirrorXBtn = document.getElementById('mirrorXBtn');
    const mirrorYBtn = document.getElementById('mirrorYBtn');
    const mirrorZBtn = document.getElementById('mirrorZBtn');
    const invertColorsBtn = document.getElementById('invertColorsBtn');

    function setupMirrorButton(button, stateVarName, axisLabel) {
        // Determine initial active state based on the global variable
        let initialGlobalState;
        if (stateVarName === 'mirrorXActive') initialGlobalState = mirrorXActive;
        else if (stateVarName === 'mirrorYActive') initialGlobalState = mirrorYActive;
        else if (stateVarName === 'mirrorZActive') initialGlobalState = mirrorZActive;

        // Set initial text and class
        button.textContent = `Mirror ${axisLabel} (${initialGlobalState ? 'On' : 'Off'})`;
        if (initialGlobalState) {
            button.classList.add('active');
        } else {
            button.classList.remove('active'); // Ensure it's off if not active
        }

        button.addEventListener('click', () => {
            let newActiveState;
            if (stateVarName === 'mirrorXActive') {
                mirrorXActive = !mirrorXActive;
                newActiveState = mirrorXActive;
            } else if (stateVarName === 'mirrorYActive') {
                mirrorYActive = !mirrorYActive;
                newActiveState = mirrorYActive;
            } else if (stateVarName === 'mirrorZActive') {
                mirrorZActive = !mirrorZActive;
                newActiveState = mirrorZActive;
            }
            
            button.textContent = `Mirror ${axisLabel} (${newActiveState ? 'On' : 'Off'})`;
            // Explicitly add or remove based on the new state
            if (newActiveState) {
                button.classList.add('active');
            } else {
                button.classList.remove('active');
            }
            console.log(`Mirror ${axisLabel} Active:`, newActiveState);
        });
    }
    setupMirrorButton(mirrorXBtn, 'mirrorXActive', 'X');
    setupMirrorButton(mirrorYBtn, 'mirrorYActive', 'Y');
    setupMirrorButton(mirrorZBtn, 'mirrorZActive', 'Z');

    // Color Inversion Button Logic
    invertColorsBtn.addEventListener('click', () => {
        if (colorInversionManager) {
            const isInverted = colorInversionManager.toggleInversion();
            invertColorsBtn.textContent = `Invert Colors (${isInverted ? 'On' : 'Off'})`;
            if (isInverted) {
                invertColorsBtn.classList.add('active');
            } else {
                invertColorsBtn.classList.remove('active');
            }
        } else {
            console.warn('Color inversion manager not yet initialized');
        }
    });

    // Post-processing Sliders
    const noiseAmountSlider = document.getElementById('noiseAmount');
    const bloomStrengthSlider = document.getElementById('bloomStrength');
    const bloomRadiusSlider = document.getElementById('bloomRadius');
    const bloomThresholdSlider = document.getElementById('bloomThreshold');
    const thresholdStrengthSlider = document.getElementById('thresholdStrength');
    const imageUploadInput = document.getElementById('imageUpload');
    const inverseThresholdCheckbox = document.getElementById('inverseThreshold');
    const audioUploadInput = document.getElementById('audioUpload');
    const audioPlayer = document.getElementById('audioPlayer');
    const backgroundContainer = document.getElementById('background-container');

    // Web Audio API setup
    let audioContext;
    let analyserNode;
    let audioSourceNode;
    let audioDataArray;
    let isAudioSetup = false;
    let lastBeatTime = 0;
    const BEAT_COOLDOWN = 0.25; // Seconds, prevent too many branches at once - slightly increased
    const BASS_THRESHOLD_BEAT = 0.95; // Increased threshold - only trigger on strong bass/snare hits

    // Frequency band definitions (approximate, will depend on sampleRate and fftSize)
    // These are indices into the audioDataArray
    let bassStartIndex, bassEndIndex;
    let midStartIndex, midEndIndex;
    let trebleStartIndex, trebleEndIndex;

    function setupAudioProcessing() {
        if (!isAudioSetup && window.audioPlayer && window.audioPlayer.src) {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyserNode = audioContext.createAnalyser();
                analyserNode.fftSize = 1024; // Increased for better frequency resolution
                analyserNode.smoothingTimeConstant = 0.75; // Add some smoothing
                audioDataArray = new Uint8Array(analyserNode.frequencyBinCount);

                // Calculate frequency band indices based on actual sample rate and fftSize
                const nyquist = audioContext.sampleRate / 2;
                const freqPerBin = nyquist / analyserNode.frequencyBinCount;
                
                bassStartIndex = 0; // Typically from ~20Hz
                bassEndIndex = Math.floor(250 / freqPerBin); // up to 250Hz
                midStartIndex = Math.floor(251 / freqPerBin);
                midEndIndex = Math.floor(2000 / freqPerBin); // 251Hz to 2000Hz
                trebleStartIndex = Math.floor(2001 / freqPerBin);
                trebleEndIndex = Math.min(Math.floor(10000 / freqPerBin), analyserNode.frequencyBinCount - 1); // 2001Hz to 10000Hz

                console.log(`Audio Setup: SampleRate=${audioContext.sampleRate}, FreqPerBin=${freqPerBin.toFixed(2)}Hz`);
                console.log(`Bands: Bass (${bassStartIndex}-${bassEndIndex}), Mid (${midStartIndex}-${midEndIndex}), Treble (${trebleStartIndex}-${trebleEndIndex})`);

                // Always create a fresh media element source
                audioSourceNode = audioContext.createMediaElementSource(window.audioPlayer);
                audioSourceNode.connect(analyserNode);
                analyserNode.connect(audioContext.destination); // Connect analyser to output to hear the audio
                
                isAudioSetup = true;
                console.log("Audio processing setup complete.");
            } catch (error) {
                console.error("Error setting up audio processing:", error);
                isAudioSetup = false;
            }
        }
    }

    function fullAudioReset() {
        console.log("Full audio reset...");
        
        // Reset timing and state variables
        lastBeatTime = 0;
        isAudioSetup = false;
        
        // Disconnect and clear everything
        if (audioSourceNode) {
            try {
                audioSourceNode.disconnect();
            } catch (e) {
                console.warn("Error disconnecting audio source:", e);
            }
        }
        
        if (audioContext && audioContext.state !== 'closed') {
            try {
                audioContext.close();
            } catch (e) {
                console.warn("Error closing audio context:", e);
            }
        }
        
        // Clear all references
        audioSourceNode = null;
        audioContext = null;
        analyserNode = null;
        audioDataArray = null;
        
        console.log("Audio reset complete");
    }

    function createNewAudioElement(src) {
        console.log("Creating new audio element...");
        
        // Remove old audio element
        const oldAudio = document.getElementById('audioPlayer');
        if (oldAudio) {
            oldAudio.remove();
        }
        
        // Create new audio element
        const newAudio = document.createElement('audio');
        newAudio.id = 'audioPlayer';
        newAudio.controls = true;
        newAudio.loop = true;
        newAudio.src = src;
        
        // Insert new audio element
        const postfxControls = document.getElementById('postfx-controls');
        postfxControls.appendChild(newAudio);
        
        // Update global reference
        window.audioPlayer = newAudio;
        
        return newAudio;
    }

    noiseAmountSlider.addEventListener('input', (event) => {
       if (noisePass) noisePass.uniforms.uNoiseAmount.value = parseFloat(event.target.value);
    });
    
    // Set initial noise slider value from shader default
    if (noisePass) noiseAmountSlider.value = noisePass.uniforms.uNoiseAmount.value;

    bloomStrengthSlider.addEventListener('input', (event) => {
        if (bloomPass) bloomPass.strength = parseFloat(event.target.value);
    });

    bloomRadiusSlider.addEventListener('input', (event) => {
        if (bloomPass) bloomPass.radius = parseFloat(event.target.value);
    });

    bloomThresholdSlider.addEventListener('input', (event) => {
        if (bloomPass) bloomPass.threshold = parseFloat(event.target.value);
    });

    thresholdStrengthSlider.addEventListener('input', (event) => { // RE-ENABLE
        if (thresholdPass) thresholdPass.uniforms.uThresholdStrength.value = parseFloat(event.target.value);
    });

    inverseThresholdCheckbox.addEventListener('change', (event) => { // RE-ENABLE
        if (thresholdPass) thresholdPass.uniforms.uInverseThreshold.value = event.target.checked;
    });

    imageUploadInput.addEventListener('change', (event) => { // RE-ENABLE
        const file = event.target.files[0];
        if (file && thresholdPass) { 
            const reader = new FileReader();
            reader.onload = (e) => {
                // Set CSS background for the div
                backgroundContainer.style.backgroundImage = `url(${e.target.result})`;

                // Still load it as a texture for the thresholding effect on sigils
                const img = new Image();
                img.onload = () => {
                    const texture = new THREE.Texture(img);
                    texture.needsUpdate = true;
                    if (thresholdPass && thresholdPass.uniforms.tThresholdMap) {
                        thresholdPass.uniforms.tThresholdMap.value = texture;
                        console.log("Threshold image texture updated for sigil effect.");
                    }
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }
    });

    audioUploadInput.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (file) {
            console.log("New audio file selected, performing full reset...");
            
            // Full reset before loading new file
            fullAudioReset();
            
            const reader = new FileReader();
            reader.onload = (e) => {
                // Create completely new audio element
                const newAudioPlayer = createNewAudioElement(e.target.result);
                console.log("New audio element created with src");
                
                // Set up event handlers for the new audio
                const setupWhenReady = () => {
                    if (newAudioPlayer.readyState >= 2) { // HAVE_CURRENT_DATA or higher
                        console.log("Audio ready, setting up processing...");
                        setTimeout(() => {
                            setupAudioProcessing();
                        }, 100);
                    }
                };
                
                newAudioPlayer.oncanplaythrough = setupWhenReady;
                newAudioPlayer.onloadeddata = setupWhenReady;
                
                // Add the standard event listeners to the new audio element
                newAudioPlayer.addEventListener('seeked', () => {
                    console.log("Audio seeked, resetting beat timing...");
                    lastBeatTime = 0;
                });

                newAudioPlayer.addEventListener('ended', () => {
                    console.log("Audio ended, resetting for potential loop...");
                    lastBeatTime = 0;
                });

                newAudioPlayer.addEventListener('play', () => {
                    console.log("Audio play event...");
                    if (audioContext && audioContext.state === 'suspended') {
                        console.log("Resuming suspended audio context...");
                        audioContext.resume().then(() => {
                            console.log("Audio context resumed successfully");
                        });
                    }
                    
                    if (!isAudioSetup && newAudioPlayer.src && newAudioPlayer.readyState >= 2) {
                        console.log("Setting up audio processing on play...");
                        setupAudioProcessing();
                    }
                });

                newAudioPlayer.addEventListener('error', (e) => {
                    console.error("Audio error:", e);
                    fullAudioReset();
                });
            };
            reader.readAsDataURL(file);
        }
    });

    addEventListener('keydown',e=>{
      if(e.code==='Space'){
        if (allSigils.length === 0) {
          console.log("Space: No sigils exist, resetting.");
          resetSigil(); 
          return; 
        }
        const targetSigil = allSigils[0]; // Always operate on the primary sigil instance
        
        if (!targetSigil) { 
            console.error("Space: No primary sigil instance found after check. Resetting.");
            resetSigil(); return;
        }

        // Call the spawnNewBranch method on the Cybersigil instance
        // It will handle parent selection and mirroring internally based on passed states
        targetSigil.spawnNewBranch(mirrorXActive, mirrorYActive, mirrorZActive);
        
      }else if(e.code==='KeyR'){
        resetSigil();
      }
    });

    const clock=new THREE.Clock();

    // For background flash decay
    let currentBackgroundColor = new THREE.Color(0x000000);
    let targetBackgroundColor = new THREE.Color(0x000000);
    const FLASH_DECAY_SPEED = 8.0; // Faster decay for more reactivity
    const FLASH_HOLD_TIME = 0.08; // Shorter hold time
    let flashHoldTimer = 0;

    function animate(){
      requestAnimationFrame(animate);
      const delta = clock.getDelta();
      const currentTime = clock.getElapsedTime();

      // Reset beat flag each frame before audio processing
      let audioFeatures = { bass: 0, mid: 0, treble: 0, beat: false, overallVolume: 0 };

      // Audio-reactive logic
      if (isAudioSetup && window.audioPlayer && !window.audioPlayer.paused) {
          analyserNode.getByteFrequencyData(audioDataArray);
          
          let bassSum = 0, midSum = 0, trebleSum = 0, overallSum = 0;
          let bassCount = 0, midCount = 0, trebleCount = 0;

          for (let i = 0; i < audioDataArray.length; i++) {
              overallSum += audioDataArray[i];
              if (i >= bassStartIndex && i <= bassEndIndex) {
                  bassSum += audioDataArray[i];
                  bassCount++;
              }
              if (i >= midStartIndex && i <= midEndIndex) {
                  midSum += audioDataArray[i];
                  midCount++;
              }
              if (i >= trebleStartIndex && i <= trebleEndIndex) {
                  trebleSum += audioDataArray[i];
                  trebleCount++;
              }
          }

          audioFeatures.overallVolume = overallSum / audioDataArray.length / 255; // Normalized
          audioFeatures.bass = bassCount > 0 ? (bassSum / bassCount) / 255 : 0; // Normalized (0-1)
          audioFeatures.mid = midCount > 0 ? (midSum / midCount) / 255 : 0;     // Normalized (0-1)
          audioFeatures.treble = trebleCount > 0 ? (trebleSum / trebleCount) / 255 : 0; // Normalized (0-1)

          // console.log(`Bass: ${audioFeatures.bass.toFixed(2)}, Mid: ${audioFeatures.mid.toFixed(2)}, Treble: ${audioFeatures.treble.toFixed(2)}`);

          if (audioFeatures.bass > BASS_THRESHOLD_BEAT && (currentTime - lastBeatTime > BEAT_COOLDOWN)) {
              lastBeatTime = currentTime;
              audioFeatures.beat = true; // Set beat flag for other systems to use (like background flash)
              console.log(`Beat detected! Bass: ${audioFeatures.bass.toFixed(2)}, Time: ${currentTime.toFixed(2)}, audioFeatures.beat = ${audioFeatures.beat}`);
              
              if (allSigils.length === 0) {
                  console.log("Audio Beat: No sigils exist. Initializing sigils now.");
                  resetSigil();
                  // After resetSigil, allSigils[0] should exist for the next beat or spacebar press
              } else {
                  const targetSigil = allSigils[0];
                  if (targetSigil) {
                      targetSigil.spawnNewBranch(mirrorXActive, mirrorYActive, mirrorZActive); 
                      console.log("Audio Beat: Spawned new branch on existing sigil.");
                  } else {
                      // This case should ideally not be reached if allSigils.length > 0 but allSigils[0] is undefined.
                      // It might indicate an issue with how sigils are added/removed from the allSigils array.
                      console.error("Audio Beat: Sigil array populated, but targetSigil is undefined. Resetting as a fallback.");
                      resetSigil();
                  }
              }
          }
      }

      // Update sigils AFTER audio processing and beat flag setting
      for(const sigilInstance of allSigils){
        sigilInstance.update(delta, isInteracting, audioFeatures); // Pass audioFeatures
      }
      
      // Auto-rotate entire scene on Z-axis when audio is playing
      if (isAudioSetup && window.audioPlayer && !window.audioPlayer.paused) {
          const autoRotationSpeed = 0.1; // Slow rotation speed (radians per second)
          scene.rotation.z += autoRotationSpeed * delta;
      }
      
      // Audio-reactive PostFX & SCENE Background
      if (isAudioSetup && window.audioPlayer && !window.audioPlayer.paused) {
        if (noisePass && noisePass.uniforms.uNoiseAmount) {
            // Noise amount is now solely controlled by its slider
            noisePass.uniforms.uNoiseAmount.value = parseFloat(noiseAmountSlider.value);
        }
        // Threshold pass could also be made reactive, e.g., uThresholdStrength based on mid frequencies
        if (thresholdPass && thresholdPass.uniforms.uThresholdStrength) {
            const baseThreshold = parseFloat(thresholdStrengthSlider.value);
            thresholdPass.uniforms.uThresholdStrength.value = THREE.MathUtils.clamp(baseThreshold + (audioFeatures.mid * 0.3) - 0.15, 0.1, 0.9);
        }

        // Audio-reactive SCENE background color - Flash effect
        // DEBUGGING: Log beat status and timer for scene background
        // console.log(`Frame: Beat = ${audioFeatures.beat}, Hold Timer = ${flashHoldTimer.toFixed(2)}, Scene BG = ${scene.background ? scene.background.getHexString() : 'null'}, CurrentColor = ${currentBackgroundColor.getHexString()}`);

        if (audioFeatures.beat) { // Flash on beat
            // DEBUGGING: Log when a beat is processed for scene flash
            // console.log("Beat TRUE - Initiating Scene Flash");
            const flashColors = [
                new THREE.Color(0.7, 0.7, 0.7),       // White
                 // Deep Red
            ];
            targetBackgroundColor.copy(flashColors[Math.floor(Math.random() * flashColors.length)]);
            currentBackgroundColor.copy(targetBackgroundColor); // currentBackgroundColor now holds the flash color
            scene.background = currentBackgroundColor; // Apply immediately
            flashHoldTimer = FLASH_HOLD_TIME; // Reset hold timer
        } else {
            if (flashHoldTimer > 0) {
                flashHoldTimer -= delta;
                // scene.background is already currentBackgroundColor (the flash color), 
                // so no change needed here during the hold period. It will be updated in the next frame if still holding.
                scene.background = currentBackgroundColor; // Ensure it stays the flash color
                // DEBUGGING: Log when scene flash is being held
                // console.log(`Holding Scene Flash: Timer = ${flashHoldTimer.toFixed(2)}, BG = ${scene.background.getHexString()}`);
            } else {
                // Resting color for scene background is black
                const restingColor = new THREE.Color(0x000000);
                
                // Lerp currentBackgroundColor towards the resting black color
                currentBackgroundColor.lerp(restingColor, delta * FLASH_DECAY_SPEED);
                scene.background = currentBackgroundColor; // Apply the lerped color
                // DEBUGGING: Log when scene flash is decaying
                // console.log(`Decaying Scene Flash: Current BG = ${scene.background.getHexString()}, Target = ${restingColor.getHexString()}`);
            }
        }
      } else { // Audio is not setup or paused
          // Ensure scene background decays to black if a flash was in progress or set to black if idle
          const restingColor = new THREE.Color(0x000000);
          if (flashHoldTimer > 0) { // If audio stops during a hold, continue hold then decay
               flashHoldTimer -= delta;
               // scene.background should remain the flash color (currentBackgroundColor)
               scene.background = currentBackgroundColor;
          } else {
              // If currentBackgroundColor is not already black, lerp it.
              // Otherwise, ensure scene.background is black.
              if (!currentBackgroundColor.equals(restingColor)) {
                  currentBackgroundColor.lerp(restingColor, delta * FLASH_DECAY_SPEED);
              } else {
                  currentBackgroundColor.copy(restingColor); // Ensure it is exactly black if lerp is done.
              }
              scene.background = currentBackgroundColor;
        }
      }

      if (noisePass) noisePass.uniforms.uTime.value += delta * 5.0; // Keep base animation for noise
      if (thresholdPass) thresholdPass.uniforms.uTime.value += delta;

      controls.update();
      // renderer.render(scene,camera); // Old rendering path
      composer.render(delta); // New rendering path with post-processing
    }
    animate();

    // resize
    addEventListener('resize',()=>{
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth,innerHeight);
      composer.setSize(innerWidth, innerHeight); // Resize composer
      if (bloomPass) {
          bloomPass.resolution.set(innerWidth, innerHeight); // Resize bloom pass
      }
    });
  </script>
</body>
</html>