<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Cybersigil Growth – Branching Animation</title>
  <style>
    html,body{margin:0;height:100%;overflow:hidden;background:#fff}
    #hud{position:fixed;top:8px;left:8px;font:12px monospace;color:#333;z-index:10}
    #hud button { margin-left: 10px; background: #555; color: #fff; border: 1px solid #333; cursor: pointer; padding: 2px 5px;}
    #mirror-controls{ position: fixed; top: 8px; right: 8px; z-index: 10; }
    #mirror-controls button { font:11px monospace; margin-left: 5px; background: #eee; color: #333; border: 1px solid #ccc; padding: 3px 6px; }
    #mirror-controls button.active { background: #333; color: #fff; border-color: #000; }
    #postfx-controls { position: fixed; bottom: 8px; left: 8px; background: rgba(255,255,255,0.8); padding: 10px; border-radius: 5px; z-index: 10; font: 11px monospace; color: #333; }
    #postfx-controls div { margin-bottom: 5px; }
    #postfx-controls label { display: inline-block; width: 120px; }
    #postfx-controls input[type=\"range\"] { width: 150px; vertical-align: middle; }
    #postfx-controls input[type=\"file\"] { margin-top: 5px; }
    #postfx-controls input[type=\"checkbox\"] { vertical-align: middle; }
    #background-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -1; background-size: cover; background-position: center center; }
  </style>
</head>
<body>
  <div id="background-container"></div>
  <div id="hud">SPACE → add branch · R → reset</div>
  <div id="mirror-controls">
    <button id="mirrorXBtn">Mirror X (On)</button>
    <button id="mirrorYBtn">Mirror Y (Off)</button>
    <button id="mirrorZBtn">Mirror Z (Off)</button>
  </div>
  <div id="postfx-controls">
    <div><label for="bloomStrength">Bloom Strength:</label><input type="range" id="bloomStrength" min="0" max="3" step="0.01" value="0.5"></div>
    <div><label for="noiseAmount">Noise Amount:</label><input type="range" id="noiseAmount" min="0" max="0.2" step="0.001" value="0.03"></div>
    <div><label for="thresholdStrength">Threshold Strength:</label><input type="range" id="thresholdStrength" min="0" max="1" step="0.01" value="0.5"></div>
    <div><label for="imageUpload">Threshold Image:</label><input type="file" id="imageUpload" accept="image/png, image/jpeg"></div>
    <div><label for="inverseThreshold">Inverse Threshold:</label><input type="checkbox" id="inverseThreshold" checked></div>
    <div><label for="audioUpload">Audio File (MP3):</label><input type="file" id="audioUpload" accept="audio/mpeg"></div>
    <audio id="audioPlayer" controls loop></audio>
  </div>
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
    import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
    import { ShaderPass } from 'three/examples/jsm/postprocessing/ShaderPass.js';
    import { OutputPass } from 'three/examples/jsm/postprocessing/OutputPass.js';
    import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';
    import { ThresholdShader } from './ThresholdShader.js'; // Import ThresholdShader
    import { Cybersigil, MAX_BRANCH_DEPTH, simplex /*, other constants if needed directly by index.html */ } from './Cybersigil.js'; // Import Cybersigil class and MAX_BRANCH_DEPTH
    // import { MarchingCubes } from 'three/examples/jsm/objects/MarchingCubes.js'; // REMOVED
    // import SimplexNoise from 'simplex-noise'; // REMOVED - Now in Cybersigil.js

    // const simplex = new SimplexNoise(); // REMOVED - Now in Cybersigil.js

    // ── Scene ─────────────────────────────────────────────────────────
    const scene  = new THREE.Scene();
    scene.background = null; // Make scene background transparent
    const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, .1, 1000);
    camera.position.set(0, 14, 90);

    const renderer = new THREE.WebGLRenderer({antialias:true, alpha: true});
    renderer.setClearAlpha(0.0); // Ensure renderer clear color is transparent
    renderer.setPixelRatio(Math.min(devicePixelRatio,2));
    renderer.setSize(innerWidth, innerHeight);
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    let isInteracting = false; // Flag for camera interaction

    controls.addEventListener('start', () => { isInteracting = true; });
    controls.addEventListener('end', () => { isInteracting = false; });

    scene.add(new THREE.HemisphereLight(0xffffff,0x444444,.9));
    const dir = new THREE.DirectionalLight(0xffffff,1.1); dir.position.set(6,12,8); scene.add(dir);

    const pmrem = new THREE.PMREMGenerator(renderer);
    scene.environment = pmrem.fromScene(new THREE.Scene(),.04).texture;

    // Post-processing
    const composer = new EffectComposer(renderer);
    const renderPass = new RenderPass(scene, camera);
    composer.addPass(renderPass);

    const thresholdPass = new ShaderPass(ThresholdShader); 
    if (thresholdPass) thresholdPass.uniforms.uInverseThreshold.value = true; 
    composer.addPass(thresholdPass); 

    // Noise Shader
    const NoiseShader = {
      uniforms: {
        'tDiffuse': { value: null },
        'uTime': { value: 0.0 },
        'uNoiseAmount': { value: 0.1 }
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float uTime;
        uniform float uNoiseAmount;
        varying vec2 vUv;

        float random(vec2 st) {
          return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
        }

        void main() {
          vec4 diffuseColor = texture2D(tDiffuse, vUv);
          float noise = (random(vUv + mod(uTime * 0.1, 100.0)) - 0.5) * uNoiseAmount; // Centered noise
          diffuseColor.rgb += noise;
          gl_FragColor = diffuseColor;
        }
      `
    };
    const noisePass = new ShaderPass(NoiseShader);
    composer.addPass(noisePass);

    const bloomPass = new UnrealBloomPass(new THREE.Vector2(innerWidth, innerHeight), 0.0, 2.0, 0.5); 
    composer.addPass(bloomPass); 

    const outputPass = new OutputPass();
    composer.addPass(outputPass);

    // ── Materials & geometry prototypes ───────────────────────────────
    const chrome = new THREE.MeshStandardMaterial({color:0xd8d8d8,metalness:1,roughness:.12,envMapIntensity:2});
    const debugMaterial = new THREE.MeshBasicMaterial({color: 0x00ff00, wireframe: true });

    // Global Sigil Management
    let allSigils = []; // Will store Cybersigil instances
    // let sigilCreationCounter = 0; // This might be managed internally by Cybersigil or not needed

    // Mirror states remain global for UI interaction
    let mirrorXActive = true; 
    let mirrorYActive = false;
    let mirrorZActive = false;

    // Child limits for density control - COMMENTED OUT for unrestricted growth
    // const MAX_CHILDREN_FOR_ROOT = 6;
    // const MAX_CHILDREN_FOR_SUBBRANCH = 3;

    // NEW Tube Geometry Constants - TO BE REPLACED/REMOVED
    // const TUBE_BASE_RADIUS = 0.3;
    // const TUBE_RADIAL_SEGMENTS = 8; 
    // const TUBE_TUBULAR_SEGMENTS_PER_UNIT_LENGTH = 1.2; 
    // const TUBE_MIN_TUBULAR_SEGMENTS = 10; 
    // const BRANCH_GROWTH_SPEED = 8.0; // MOVED

    // Spike Constants - TO BE REPLACED/REMOVED LATER
    // const SPIKE_PROBABILITY = 0.25; 
    // const SPIKES_PER_UNIT_LENGTH = 1.2; 
    // const SPIKE_BASE_LENGTH = 0.5; 
    // const SPIKE_BASE_RADIUS = 0.01; 
    // const SPIKE_RADIAL_SEGMENTS = 4; 
    // const SPIKE_TAPER_POWER = 0.5; 

    // Dynamic Geometry Constants
    // const MAX_POINTS_PER_BRANCH_PATH = 150; // MOVED
    // OLD: const MAX_VERTICES_FOR_LINE_GEOMETRY = (MAX_POINTS_PER_BRANCH_PATH -1) * 2 * 3;
    // NEW: Each path segment (MAX_POINTS_PER_BRANCH_PATH segments) becomes a quad (6 vertices).
    // OLD: const LINE_THICKNESS = 0.3; 
    // OLD: const LINE_TAPER_POWER = 1.5; 
    // OLD: const LINE_DEPTH_SCALE_FACTOR = 0.75; 

    // New constants for 3D tubes
    // const TUBE_SIDES = 6; // MOVED
    // const TUBE_BASE_RADIUS = 0.25; // MOVED
    // const TUBE_TAPER_POWER = 1.5;  // MOVED
    // const TUBE_DEPTH_SCALE_FACTOR = 0.75; // MOVED
    // const TUBE_INK_BLEED_OFFSET = 0.08; // MOVED

    // Max vertices: path segments * tube sides * 6 vertices per quad
    // THIS IS THE ONLY DEFINITION that should exist for MAX_VERTICES_PER_BRANCH_GEOMETRY
    // const MAX_VERTICES_PER_BRANCH_GEOMETRY = MAX_POINTS_PER_BRANCH_PATH * TUBE_SIDES * 6; // MOVED
    // Ensured old definition is removed by explicitly targeting its previous common location if it was missed.
    // For example, it might have been near line 78 or 90 if based on older constants.

    // New material specifically for branches
    // const BRANCH_MATERIAL = new THREE.MeshStandardMaterial({ ... }); // MOVED
    // const INK_BLEED_MATERIAL = new THREE.MeshStandardMaterial({ ... }); // MOVED

    // Helper vectors and function for triangle strip generation
    // const globalReferenceUp = new THREE.Vector3(0, 1, 0); // MOVED
    // const globalReferenceRight = new THREE.Vector3(1, 0, 0); // MOVED
    // const tempVecP1 = new THREE.Vector3(); // MOVED
    // const tempVecP2 = new THREE.Vector3(); // MOVED
    // const tempTangent1 = new THREE.Vector3(); // MOVED
    // const tempSide = new THREE.Vector3(); // MOVED
    // const tempNormal = new THREE.Vector3(); // MOVED
    // const edge1 = new THREE.Vector3();      // MOVED
    // const edge2 = new THREE.Vector3();      // MOVED
    // const tempBiNormal = new THREE.Vector3(); // MOVED
    // const crossSectionVertex = new THREE.Vector3(); // MOVED

    /* MOVED TO Cybersigil.js
    function getSideVector(tangent, outSideVec) {
        outSideVec.crossVectors(tangent, globalReferenceUp).normalize();
        if (outSideVec.lengthSq() < 0.0001) { // tangent is collinear with referenceUp
            outSideVec.crossVectors(tangent, globalReferenceRight).normalize();
        }
        // Ensure it's truly normalized if cross product was with a near-collinear fallback
        if (outSideVec.lengthSq() < 0.0001) { // very unlikely, e.g. tangent is zero vector
            outSideVec.set(1,0,0); // Default to X axis if all else fails
        }
        return outSideVec;
    }
    */

    // Branch object structure
    /* MOVED TO Cybersigil.js
    function createBranch(startPos, direction, seed, depth){ 
      const SEG_POINTS = MAX_POINTS_PER_BRANCH_PATH;
      const LEN  = (depth === 0) ? 15 : Math.max(3, 15 / (depth * 1.5)); 
      const curvePts  = [];
      for(let i=0;i<=SEG_POINTS;i++){
        const u=i/SEG_POINTS;
        const z=u*LEN;
        const sway = simplex.noise2D(u*2+seed,seed)*1.5 * (1 / (depth + 1));
        const bend = simplex.noise2D(u*2+seed+20,seed-10)*1.5 * (1 / (depth + 1));
        const right = new THREE.Vector3().crossVectors(direction,new THREE.Vector3(0,1,0)).normalize();
        const up    = new THREE.Vector3().crossVectors(right,direction).normalize();
        const p = new THREE.Vector3().copy(startPos)
          .addScaledVector(direction,z)
          .addScaledVector(right,sway)
          .addScaledVector(up,bend);
        curvePts.push(p);
      }

      for (let pt of curvePts) {
        const dx = simplex.noise3D(pt.x * NOISE_DISPLACEMENT_SCALE, pt.y * NOISE_DISPLACEMENT_SCALE, pt.z * NOISE_DISPLACEMENT_SCALE + seed) * NOISE_DISPLACEMENT_STRENGTH * (1/(depth+1));
        const dy = simplex.noise3D(pt.y * NOISE_DISPLACEMENT_SCALE, pt.z * NOISE_DISPLACEMENT_SCALE, pt.x * NOISE_DISPLACEMENT_SCALE + seed + 5) * NOISE_DISPLACEMENT_STRENGTH * (1/(depth+1));
        const dz = simplex.noise3D(pt.z * NOISE_DISPLACEMENT_SCALE, pt.x * NOISE_DISPLACEMENT_SCALE, pt.y * NOISE_DISPLACEMENT_SCALE + seed + 10) * NOISE_DISPLACEMENT_STRENGTH * (1/(depth+1));
        pt.add(new THREE.Vector3(dx, dy, dz));
      }

      const curve = new THREE.CatmullRomCurve3(curvePts);
      const curveLength = curve.getLength();

      const positionsArray = new Float32Array(MAX_VERTICES_PER_BRANCH_GEOMETRY * 3);
      const normalsArray = new Float32Array(MAX_VERTICES_PER_BRANCH_GEOMETRY * 3); // For lighting
      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.BufferAttribute(positionsArray, 3).setUsage(THREE.DynamicDrawUsage));
      geometry.setAttribute('normal', new THREE.BufferAttribute(normalsArray, 3).setUsage(THREE.DynamicDrawUsage)); // Add normal attribute
      
      const mesh = new THREE.Mesh(geometry, BRANCH_MATERIAL); // Use new BRANCH_MATERIAL
      geometry.setDrawRange(0, 0); 
      
      // Ink Bleed Mesh
      const bleedPositionsArray = new Float32Array(MAX_VERTICES_PER_BRANCH_GEOMETRY * 3);
      const bleedNormalsArray = new Float32Array(MAX_VERTICES_PER_BRANCH_GEOMETRY * 3);
      const bleedGeometry = new THREE.BufferGeometry();
      bleedGeometry.setAttribute('position', new THREE.BufferAttribute(bleedPositionsArray, 3).setUsage(THREE.DynamicDrawUsage));
      bleedGeometry.setAttribute('normal', new THREE.BufferAttribute(bleedNormalsArray, 3).setUsage(THREE.DynamicDrawUsage));
      
      const bleedMesh = new THREE.Mesh(bleedGeometry, INK_BLEED_MATERIAL);
      bleedGeometry.setDrawRange(0, 0);

      console.log(`CreateBranch (depth ${depth}, seed ${seed.toFixed(0)}): totalLength=${curveLength.toFixed(2)}, curvePoints.length=${curvePts.length}, MaxVertices=${MAX_VERTICES_PER_BRANCH_GEOMETRY}`);

      return {
        curve,
        curvePoints: curvePts,
        mesh: mesh, 
        bleedMesh: bleedMesh, // Add bleed mesh
        currentLength: 0,
        totalLength: curveLength,
        drawnPathSegments: 0,
        currentVertexCount: 0, 
        currentBleedVertexCount: 0, // For bleed mesh
        childrenSpawned: 0,
        seed,
        depth
      };
    }
    */

    function resetSigil(){
      allSigils.forEach(sigilInstance => {
        sigilInstance.dispose(); // Call dispose method on Cybersigil instance
      });
      allSigils.length = 0;
      // sigilCreationCounter = 0; // Reset if used

      const rootInitialGroupPos = new THREE.Vector3(0,0,-10);
      const primaryRootDir = new THREE.Vector3(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1).normalize();
      if (primaryRootDir.lengthSq() === 0) primaryRootDir.set(0,0,1); 
      const primaryRootSeed = Math.random() * 1000;
      
      // Create the new Cybersigil instance, passing the current mirror states
      const newSigil = new Cybersigil(scene, rootInitialGroupPos, primaryRootDir, primaryRootSeed, mirrorXActive, mirrorYActive, mirrorZActive);
      allSigils.push(newSigil);
      console.log("Main: New Cybersigil instance created and added.");
    }

    // Mirror Button Logic
    const mirrorXBtn = document.getElementById('mirrorXBtn');
    const mirrorYBtn = document.getElementById('mirrorYBtn');
    const mirrorZBtn = document.getElementById('mirrorZBtn');

    function setupMirrorButton(button, stateVarName, axisLabel) {
        // Determine initial active state based on the global variable
        let initialGlobalState;
        if (stateVarName === 'mirrorXActive') initialGlobalState = mirrorXActive;
        else if (stateVarName === 'mirrorYActive') initialGlobalState = mirrorYActive;
        else if (stateVarName === 'mirrorZActive') initialGlobalState = mirrorZActive;

        // Set initial text and class
        button.textContent = `Mirror ${axisLabel} (${initialGlobalState ? 'On' : 'Off'})`;
        if (initialGlobalState) {
            button.classList.add('active');
        } else {
            button.classList.remove('active'); // Ensure it's off if not active
        }

        button.addEventListener('click', () => {
            let newActiveState;
            if (stateVarName === 'mirrorXActive') {
                mirrorXActive = !mirrorXActive;
                newActiveState = mirrorXActive;
            } else if (stateVarName === 'mirrorYActive') {
                mirrorYActive = !mirrorYActive;
                newActiveState = mirrorYActive;
            } else if (stateVarName === 'mirrorZActive') {
                mirrorZActive = !mirrorZActive;
                newActiveState = mirrorZActive;
            }
            
            button.textContent = `Mirror ${axisLabel} (${newActiveState ? 'On' : 'Off'})`;
            // Explicitly add or remove based on the new state
            if (newActiveState) {
                button.classList.add('active');
            } else {
                button.classList.remove('active');
            }
            console.log(`Mirror ${axisLabel} Active:`, newActiveState);
        });
    }
    setupMirrorButton(mirrorXBtn, 'mirrorXActive', 'X');
    setupMirrorButton(mirrorYBtn, 'mirrorYActive', 'Y');
    setupMirrorButton(mirrorZBtn, 'mirrorZActive', 'Z');

    // Post-processing Sliders
    const bloomStrengthSlider = document.getElementById('bloomStrength');
    const noiseAmountSlider = document.getElementById('noiseAmount');
    const thresholdStrengthSlider = document.getElementById('thresholdStrength');
    const imageUploadInput = document.getElementById('imageUpload');
    const inverseThresholdCheckbox = document.getElementById('inverseThreshold');
    const audioUploadInput = document.getElementById('audioUpload');
    const audioPlayer = document.getElementById('audioPlayer');
    const backgroundContainer = document.getElementById('background-container');

    // Web Audio API setup
    let audioContext;
    let analyserNode;
    let audioSourceNode;
    let audioDataArray;
    let isAudioSetup = false;
    let lastBeatTime = 0;
    const BEAT_COOLDOWN = 0.25; // Seconds, prevent too many branches at once - slightly increased
    const BASS_THRESHOLD_BEAT = 0.5; // Normalized bass value (0-1) to trigger a beat - adjust this!

    // Frequency band definitions (approximate, will depend on sampleRate and fftSize)
    // These are indices into the audioDataArray
    let bassStartIndex, bassEndIndex;
    let midStartIndex, midEndIndex;
    let trebleStartIndex, trebleEndIndex;

    function setupAudioProcessing() {
        if (!isAudioSetup && audioPlayer.src) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyserNode = audioContext.createAnalyser();
            analyserNode.fftSize = 1024; // Increased for better frequency resolution
            analyserNode.smoothingTimeConstant = 0.75; // Add some smoothing
            audioDataArray = new Uint8Array(analyserNode.frequencyBinCount);

            // Calculate frequency band indices based on actual sample rate and fftSize
            const nyquist = audioContext.sampleRate / 2;
            const freqPerBin = nyquist / analyserNode.frequencyBinCount;
            
            bassStartIndex = 0; // Typically from ~20Hz
            bassEndIndex = Math.floor(250 / freqPerBin); // up to 250Hz
            midStartIndex = Math.floor(251 / freqPerBin);
            midEndIndex = Math.floor(2000 / freqPerBin); // 251Hz to 2000Hz
            trebleStartIndex = Math.floor(2001 / freqPerBin);
            trebleEndIndex = Math.min(Math.floor(10000 / freqPerBin), analyserNode.frequencyBinCount - 1); // 2001Hz to 10000Hz

            console.log(`Audio Setup: SampleRate=${audioContext.sampleRate}, FreqPerBin=${freqPerBin.toFixed(2)}Hz`);
            console.log(`Bands: Bass (${bassStartIndex}-${bassEndIndex}), Mid (${midStartIndex}-${midEndIndex}), Treble (${trebleStartIndex}-${trebleEndIndex})`);

            // Create an audio source from the <audio> element if it doesn't exist or if the context was recreated
            if (!audioSourceNode || audioSourceNode.mediaElement !== audioPlayer) {
                 if (audioSourceNode) {
                    audioSourceNode.disconnect(); // Disconnect old source if any
                 }
                audioSourceNode = audioContext.createMediaElementSource(audioPlayer);
            }

            audioSourceNode.connect(analyserNode);
            analyserNode.connect(audioContext.destination); // Connect analyser to output to hear the audio
            isAudioSetup = true;
            console.log("Audio processing setup complete.");
        }
    }

    bloomStrengthSlider.addEventListener('input', (event) => {
       if (bloomPass) bloomPass.strength = parseFloat(event.target.value);
    });
    bloomStrengthSlider.value = "0.0"; // Ensure slider starts at 0 to match initial pass strength

    noiseAmountSlider.addEventListener('input', (event) => {
       if (noisePass) noisePass.uniforms.uNoiseAmount.value = parseFloat(event.target.value);
    });
    
    // Set initial noise slider value from shader default
    if (noisePass) noiseAmountSlider.value = noisePass.uniforms.uNoiseAmount.value;

    thresholdStrengthSlider.addEventListener('input', (event) => { // RE-ENABLE
        if (thresholdPass) thresholdPass.uniforms.uThresholdStrength.value = parseFloat(event.target.value);
    });

    inverseThresholdCheckbox.addEventListener('change', (event) => { // RE-ENABLE
        if (thresholdPass) thresholdPass.uniforms.uInverseThreshold.value = event.target.checked;
    });

    imageUploadInput.addEventListener('change', (event) => { // RE-ENABLE
        const file = event.target.files[0];
        if (file && thresholdPass) { 
            const reader = new FileReader();
            reader.onload = (e) => {
                // Set CSS background for the div
                backgroundContainer.style.backgroundImage = `url(${e.target.result})`;

                // Still load it as a texture for the thresholding effect on sigils
                const img = new Image();
                img.onload = () => {
                    const texture = new THREE.Texture(img);
                    texture.needsUpdate = true;
                    if (thresholdPass && thresholdPass.uniforms.tThresholdMap) {
                        thresholdPass.uniforms.tThresholdMap.value = texture;
                        console.log("Threshold image texture updated for sigil effect.");
                    }
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }
    });

    audioUploadInput.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                audioPlayer.src = e.target.result;
                audioPlayer.oncanplaythrough = () => {
                    // (Re)setup audio processing when a new file is loaded and ready
                    isAudioSetup = false; // Reset flag to allow setup
                    if (audioContext && audioContext.state === 'suspended') {
                        audioContext.resume();
                    }
                    setupAudioProcessing();
                    // audioPlayer.play(); // Optional: auto-play
                    console.log("Audio file loaded, processing (re)initialized.");
                };
            };
            reader.readAsDataURL(file);
        }
    });

    addEventListener('keydown',e=>{
      if(e.code==='Space'){
        if (allSigils.length === 0) {
          console.log("Space: No sigils exist, resetting.");
          resetSigil(); 
          return; 
        }
        const targetSigil = allSigils[0]; // Always operate on the primary sigil instance
        
        if (!targetSigil) { 
            console.error("Space: No primary sigil instance found after check. Resetting.");
            resetSigil(); return;
        }

        // Call the spawnNewBranch method on the Cybersigil instance
        // It will handle parent selection and mirroring internally based on passed states
        targetSigil.spawnNewBranch(mirrorXActive, mirrorYActive, mirrorZActive);
        
      }else if(e.code==='KeyR'){
        resetSigil();
      }
    });

    const clock=new THREE.Clock();

    function animate(){
      requestAnimationFrame(animate);
      const delta = clock.getDelta();
      const currentTime = clock.getElapsedTime();

      let audioFeatures = { bass: 0, mid: 0, treble: 0, beat: false, overallVolume: 0 };

      // Audio-reactive logic
      if (isAudioSetup && audioPlayer.paused === false) {
          analyserNode.getByteFrequencyData(audioDataArray);
          
          let bassSum = 0, midSum = 0, trebleSum = 0, overallSum = 0;
          let bassCount = 0, midCount = 0, trebleCount = 0;

          for (let i = 0; i < audioDataArray.length; i++) {
              overallSum += audioDataArray[i];
              if (i >= bassStartIndex && i <= bassEndIndex) {
                  bassSum += audioDataArray[i];
                  bassCount++;
              }
              if (i >= midStartIndex && i <= midEndIndex) {
                  midSum += audioDataArray[i];
                  midCount++;
              }
              if (i >= trebleStartIndex && i <= trebleEndIndex) {
                  trebleSum += audioDataArray[i];
                  trebleCount++;
              }
          }

          audioFeatures.overallVolume = overallSum / audioDataArray.length / 255; // Normalized
          audioFeatures.bass = bassCount > 0 ? (bassSum / bassCount) / 255 : 0; // Normalized (0-1)
          audioFeatures.mid = midCount > 0 ? (midSum / midCount) / 255 : 0;     // Normalized (0-1)
          audioFeatures.treble = trebleCount > 0 ? (trebleSum / trebleCount) / 255 : 0; // Normalized (0-1)

          // console.log(`Bass: ${audioFeatures.bass.toFixed(2)}, Mid: ${audioFeatures.mid.toFixed(2)}, Treble: ${audioFeatures.treble.toFixed(2)}`);

          if (audioFeatures.bass > BASS_THRESHOLD_BEAT && (currentTime - lastBeatTime > BEAT_COOLDOWN)) {
              console.log(`Beat detected! Bass: ${audioFeatures.bass.toFixed(2)}, Time: ${currentTime.toFixed(2)}`);
              lastBeatTime = currentTime;
              audioFeatures.beat = true; // Set beat flag
              
              if (allSigils.length === 0) {
                  console.log("Audio Beat: No sigils exist, resetting.");
                  resetSigil();
              } else {
                  const targetSigil = allSigils[0];
                  if (targetSigil) {
                      // SpawnNewBranch will now be called based on audioFeatures.beat by the sigil's update method, or here directly if preferred.
                      // For now, let's keep direct spawning here based on the detected beat.
                      targetSigil.spawnNewBranch(mirrorXActive, mirrorYActive, mirrorZActive); 
                      console.log("Audio Beat: Spawned new branch directly.");
                  } else {
                      console.error("Audio Beat: No primary sigil instance found. Resetting.");
                      resetSigil();
                  }
              }
          }
      }

      for(const sigilInstance of allSigils){
        sigilInstance.update(delta, isInteracting, audioFeatures); // Pass audioFeatures
      }
      
      // Audio-reactive PostFX
      if (isAudioSetup && audioPlayer.paused === false) {
        if (bloomPass) {
            // Example: Bass drives bloom strength. Clamp to avoid extreme values.
            // The default bloom strength is 0.0 as per earlier reset.
            // Let's make it so bass ADDS to a base level or the slider level.
            const baseBloom = parseFloat(bloomStrengthSlider.value); // Get current slider value
            bloomPass.strength = THREE.MathUtils.clamp(baseBloom + (audioFeatures.bass * 0.5), 0, 1.5); 
        }
        if (noisePass && noisePass.uniforms.uNoiseAmount) {
            // Noise amount is now solely controlled by its slider
            noisePass.uniforms.uNoiseAmount.value = parseFloat(noiseAmountSlider.value);
        }
        // Threshold pass could also be made reactive, e.g., uThresholdStrength based on mid frequencies
        if (thresholdPass && thresholdPass.uniforms.uThresholdStrength) {
            const baseThreshold = parseFloat(thresholdStrengthSlider.value);
            thresholdPass.uniforms.uThresholdStrength.value = THREE.MathUtils.clamp(baseThreshold + (audioFeatures.mid * 0.3) - 0.15, 0.1, 0.9);
        }

        // Audio-reactive background color
        if (backgroundContainer) {
            // Use different audio features for background channels to contrast with sigils
            // Sigil base color uses: R=bass, G=mid, B=treble
            // Background will use: R=treble, G=bass, B=mid (approximately)
            // Clamped to be somewhat muted and not pure black/white.
            const bgR = THREE.MathUtils.clamp(audioFeatures.treble * 0.6 + 0.1, 0.1, 0.7); 
            const bgG = THREE.MathUtils.clamp(audioFeatures.bass * 0.6 + 0.1, 0.1, 0.7);
            const bgB = THREE.MathUtils.clamp(audioFeatures.mid * 0.6 + 0.1, 0.1, 0.7);
            const bgColor = new THREE.Color(bgR, bgG, bgB);
            backgroundContainer.style.backgroundColor = bgColor.getStyle();
        }
      }

      if (noisePass) noisePass.uniforms.uTime.value += delta * 5.0; // Keep base animation for noise
      if (thresholdPass) thresholdPass.uniforms.uTime.value += delta;

      controls.update();
      // renderer.render(scene,camera); // Old rendering path
      composer.render(delta); // New rendering path with post-processing
    }
    animate();

    // resize
    addEventListener('resize',()=>{
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth,innerHeight);
      composer.setSize(innerWidth, innerHeight); // Resize composer
      if (bloomPass) bloomPass.setSize(innerWidth, innerHeight);
    });
  </script>
</body>
</html>